# -*- coding: utf-8 -*-
"""yuen_praticum2_finalsubmission

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11UedZX_DD1loDi4UaJ5jv6RqKfzZakS7
"""

from dataclasses import dataclass
import numpy as np
from numpy.typing import ArrayLike 
from typing import Callable
from typing import Tuple
import matplotlib.pyplot as plt

@dataclass
class DCMotorConfig:
  R: float
  L: float
  b: float
  J: float
  Km: float
  Ktau: float



cfg = DCMotorConfig(R=1.8, L=0.85e-2, Km=4.6, Ktau=6.2, b=0.035, J=0.032)
print(cfg.R) # 1.8
print(cfg.Ktau) # 6.2

#tetsing to make sure values are correct

import numpy as np
import math

class DCMotor:
  def __init__(self, motor_cfg: DCMotorConfig) -> None:
  # Extract motor_cfg and store in A and B matrices
    self.A =  np.array([[-1*motor_cfg.R/motor_cfg.L, 0, -1*motor_cfg.Km/motor_cfg.L],
              [0, 0, 1],
              [motor_cfg.Ktau/3, 0, -1*motor_cfg.b/motor_cfg.J]]) # ...
    self.B = np.array([1/motor_cfg.L,
                       0,
                       0]) #...
  def __call__(self, x: ArrayLike, u: float) -> ArrayLike:
  # Implement your linear dynamics!
    x_dot = self.A @ x + self.B.dot(u) 
    return x_dot


#testing1
dc_test = DCMotor(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =2.0
print(dc_test(dc_stats, u))

"""Input voltage of 2V"""

#testing2
dc_test_minus2 = DCMotor(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =-2.0
print(dc_test_minus2(dc_stats, u))

"""0.0 Amps, 0 rad, and 0 rad/s. Input votlage of -2V"""

#testing3
dc_test = DCMotor(cfg)
dc_stats = np.array([1.0,0.0,0.0])
u =0.0
print(dc_test(dc_stats, u))

"""1.0 Amps, 0 rad, and 0 rad/s. Input voltage of 0 v

Deliverable: Describe what you think is happening physically in each case above. Does
the result of your routine make sense based on your intuition?


I think what is happening is that in the various test cases we can mathematically see how the application 
or lack of a current and voltage can be modelled on a motor. For example on the first test case, all the values 
of the input array was set to 0 and a voltage of 2V was applied. Howver the lack of current means the motor has
not staretd spinning. in the last/3rd test we can see that a current is being apllied but the lack of a voltage 
means the motor will come to a stop.
"""

def unit_impulse(t: float) -> float:
  if t == 0:
    return 1.0
  else :
    return  0.

# Write your implementation

def unit_step(t: float) -> float:
  if t >= 0:
    return 1.0
  else: 
    return  0.0

# Write your implementation

def sin_wave(t: float) -> float:
  A= 5
  phi = 0
  omega =2* math.pi
  u_result = A *math.sin((omega*t) + phi)
  return  u_result

def zero_func(void):
  return 0.0

def rk2_integration(dyn_func: callable, u_func: callable, x_0: float,
t_0: float, t_f: float, delta_t: float) -> list:
    #t=t_0
    x_now = x_0
    list_return = [x_now]
    time_array= np.arange(t_0,t_f,delta_t)#keeps trakc of index and time value
    for i,t in enumerate(time_array):
      f_1 = dyn_func(list_return[i],u_func(t))
      f_2 = dyn_func((list_return[i]+(delta_t/2)*f_1),(u_func(t+(delta_t/2))))
      temp = x_now +delta_t *f_2
      list_return.append(temp)
      x_now = temp
      
    return list_return,time_array
#np.arange, enumerate

# This used to be our main DCMotor class
class DCMotorDynamics:

  def __init__(self, cfg: DCMotorConfig):
    self.A =  np.array([[-1*cfg.R/cfg.L, 0, -1*cfg.Km/cfg.L],
              [0, 0, 1],
              [cfg.Ktau/cfg.J, 0, -1*cfg.b/cfg.J]]) # ...
    self.B = np.array([1/cfg.L,
                       0 ,
                       0]) #...
    # This class is what you did in Practicum 2-1!
    

  def __call__(self, x: ArrayLike, u: float):
    x_dot = self.A @ x + self.B.dot(u) # <-- A needs to use matrix multiplication with x
    #x_dot = self.A.dot(x)+self.B.dot(u) # <---- This created a broadcast error. I fixed your B matrix.
    return x_dot
 

# This wrapper class represents your DCMotor plant:
class DCMotor:

  def __init__(self, cfg: DCMotorConfig):
    self.config = cfg
    self.dynamics = DCMotorDynamics(cfg)
  
  def output(self, x: ArrayLike):
    theta = x[1]
    # Here you will pick out the entry of the state vector that represents the
    # desired output
    # ...Implement...
    return theta

#testing1
dc_test = DCMotorDynamics(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =2.0
print(dc_test(dc_stats, u))

#tsting 2
dc_test_minus2 = DCMotorDynamics(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =-2.0
print(dc_test_minus2(dc_stats, u))

#testing3
dc_test = DCMotorDynamics(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =-2.0
print(dc_test(dc_stats, u))

def rk2_step(dyn_func: Callable, u_func: Callable, x: ArrayLike,
t: float, delta_t: float) -> ArrayLike:
  #list_return =
  f_1 = dyn_func(x,u_func(t))
  #print(f_1)
  f_2 = dyn_func((x+(delta_t/2)*f_1),(u_func(t+(delta_t/2))))
  temp = x +delta_t *f_2
  return temp
# Compute the *same* steps from your RK2 Integration routine

def simulate(plant, controller, x_0: ArrayLike, t_0: float, t_f: float,
delta_t: float) -> Tuple[ArrayLike, ArrayLike]:
    x_now = x_0
    list_return = [x_now]
    y_array = []
    time_array= np.arange(t_0,t_f,delta_t)#keeps trakc of index and time value
    for i,t in enumerate(time_array):
      #measure
      y = plant.output(x_now)
      y_array.append(y)
      #/store
      u_func = lambda t, measurement=y: controller(measurement)
      temp = rk2_step(plant.dynamics,u_func,x_now,t,delta_t)
      list_return.append(temp)
      x_now = temp
  
    return time_array,  np.array(y_array) # <-- I fixed your simulate function to return y_array as a numpy array!

# Setup your time and output histories
# Iterate over the time range just like before
  # Measure/store plant output using its interface
  # Apply controller using Python lambda
  # Take rk2_step
# Return the tuple of time and output histories

#testing Rk2

t_0 = 0.0
delta_t = 0.001
t_f = 0.5
dc_rk2_test = DCMotor(cfg)
cfg = DCMotorConfig(R=1.8, L=0.85e-2, Km=4.6, Ktau=6.2, b=0.035, J=0.032)
dcmotork2_test = DCMotor(cfg)
x = np.array([0,0,0])
x_testdata_1= rk2_integration(dcmotork2_test.dynamics,unit_impulse, x, t_0, t_f, delta_t)
x_testdata_2= rk2_integration(dcmotork2_test.dynamics,unit_step, x, t_0, t_f, delta_t)
x_testdata_3= rk2_integration(dcmotork2_test.dynamics,sin_wave, x, t_0, t_f, delta_t)
x_testdata_3= rk2_integration(dcmotork2_test.dynamics,sin_wave, x, t_0, t_f, delta_t)

new_x = np.array([2.5,0,0])
x_testdata_4= rk2_integration(dcmotork2_test.dynamics,sin_wave, new_x, t_0, t_f, delta_t)


plt.figure()
figure, sub_fig = plt.subplots(1, figsize=(10,20)) 
plt.subplot(8,2,1)
plt.plot(x_testdata_1[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle for unit impulse')

plt.subplot(8,2,2)
plt.plot(x_testdata_1[1])
plt.xlabel('time')
plt.ylabel('angular velocity')
plt.title('time vs angular velocity for unit impulse')

plt.subplot(8,2,3)
plt.plot(x_testdata_2[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle for unit step')

plt.subplot(8,2,4)
plt.plot(x_testdata_2[1])
plt.xlabel('time')
plt.ylabel('angular velocity')
plt.title('time vs angular velocity for unit step')

plt.subplot(8,2,5)
plt.plot(x_testdata_3[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle sin wave')

plt.subplot(8,2,6)
plt.plot(x_testdata_3[1])
plt.xlabel('time')
plt.ylabel('angular velcoity')
plt.title('time vs angular velcotiy for sin wave')

plt.subplot(8,2,7)
plt.plot(x_testdata_4[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle zero func')

plt.subplot(8,2,8)
plt.plot(x_testdata_4[1])
plt.xlabel('time')
plt.ylabel('angular')
plt.title('time vs angular zero func')
plt.tight_layout()
plt.show()

"""Describe what you think is happening to these variables given the initial conditions and
input functions. Does it make sense physically?


What i think is happening given the initial conditions is that the time vs angle graph does not equal 0. 
This is becuase the unit impulse is a small value applied to the motor and doesn't affect it. When looking 
at the angular velcoity graph we can see that the motor will rotate before coming to a stop. With the unit step
we can see that the motor moves at a constant rate. When a sinusoidal signal is applied we see that a siusodial 
wave is produced represnting the motor speed in respect to the voltage and current applied. For when the motor
starts with an iniital current of 2.5 Amps applied and 0 volts we can see that the motor will eventually stop 
moving and stablizie at 0 once the current is used up. 
"""

class DummyController:
# DummyController returns 0.0
  def __init__(self):
    self.value = 0.0
  def __call__(self, measurement: float):
    return self.value

Dummycontroller1 =DummyController()
dc_motortest = DCMotor(cfg)
ts, ys = simulate(dc_motortest,Dummycontroller1,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 0.5,delta_t = 0.001)

# So you have an error with t or y here. Time to see what they look like.
# print(ts.shape)
# print(ys) # Your y is a collection of state vectors! Yikes!
# print(np.array(ys).shape) # There is something wrong here! It says you are building a numpy array in a weird way. So y is messed up!

# When you have a bug, you need to chase it down!
# Comment out what is not working...
plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()
#plot theta

@dataclass
class PIDControllerConfig:
  Kp: float
  Ki: float
  Kd: float
  delta_t: float
  setpoint: float

class PIDController:
  def __init__(self, cfg: PIDControllerConfig) -> None:
    self.Kp = cfg.Kp
    self.Ki = cfg.Ki
    self.Kd =cfg.Kd
    self.delta_t = cfg.delta_t
    self.setpoint = cfg.setpoint
    self.area =0
    self.et_minus =0
  # write your implementation

  def __call__(self, measurement: float) -> float:
    e_t= self.setpoint- measurement
    self.area += e_t*self.delta_t
    u_t = (self.Kp * e_t)+(self.Ki *self.area )+ (self.Kd *((e_t -self.et_minus)/self.delta_t))
    self.et_minus = e_t
    return u_t

  # write your implementation

#testing my sanity
dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=10.0,Ki=100.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.
𝐾_𝑃 = 10. 0, 𝐾_𝐼 = 0. 0, 𝐾_𝐷 = 0. 0. Setpoint at 1"""

dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=0.0,Ki=10.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.
𝐾_𝑃 = 0. 0, 𝐾_𝐼 = 10. 0, 𝐾_𝐷 = 0. 0. Setpoint at 1"""

dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=2.0,Ki=0.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.
𝐾_𝑃 = 2. 0, 𝐾_𝐼 = 0. 0, 𝐾_𝐷 = 0. 0. Setpoint at 1"""

dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=10.0,Ki=0.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.𝐾_𝑃 = 10. 0, 𝐾_𝐼 = 0. 0, 𝐾_𝐷 = 0. 0. Setpoint at 1

Deliverable: For each case, plot the motor angle (θ) over your simulated time horizon.
Describe what you think is happening in each case above. How do the different
parameter values affect the controller’s performance?

As kp increases, the contrller becomes more controllable. This can be seen in the last 2 plots of Kp of 2 and Kp of 10 respectively. 
As the values increaed it can be seen the system converges to a vlaue of 1 radian and as result becomes more controllabe.
"""