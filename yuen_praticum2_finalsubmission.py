# -*- coding: utf-8 -*-
"""yuen_praticum2_finalsubmission

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11UedZX_DD1loDi4UaJ5jv6RqKfzZakS7
"""

from dataclasses import dataclass
import numpy as np
from numpy.typing import ArrayLike 
from typing import Callable
from typing import Tuple
import matplotlib.pyplot as plt

@dataclass
class DCMotorConfig:
  R: float
  L: float
  b: float
  J: float
  Km: float
  Ktau: float



cfg = DCMotorConfig(R=1.8, L=0.85e-2, Km=4.6, Ktau=6.2, b=0.035, J=0.032)
print(cfg.R) # 1.8
print(cfg.Ktau) # 6.2

#tetsing to make sure values are correct

import numpy as np
import math

class DCMotor:
  def __init__(self, motor_cfg: DCMotorConfig) -> None:
  # Extract motor_cfg and store in A and B matrices
    self.A =  np.array([[-1*motor_cfg.R/motor_cfg.L, 0, -1*motor_cfg.Km/motor_cfg.L],
              [0, 0, 1],
              [motor_cfg.Ktau/3, 0, -1*motor_cfg.b/motor_cfg.J]]) # ...
    self.B = np.array([1/motor_cfg.L,
                       0,
                       0]) #...
  def __call__(self, x: ArrayLike, u: float) -> ArrayLike:
  # Implement your linear dynamics!
    x_dot = self.A @ x + self.B.dot(u) 
    return x_dot


#testing1
dc_test = DCMotor(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =2.0
print(dc_test(dc_stats, u))

"""Input voltage of 2V"""

#testing2
dc_test_minus2 = DCMotor(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =-2.0
print(dc_test_minus2(dc_stats, u))

"""0.0 Amps, 0 rad, and 0 rad/s. Input votlage of -2V"""

#testing3
dc_test = DCMotor(cfg)
dc_stats = np.array([1.0,0.0,0.0])
u =0.0
print(dc_test(dc_stats, u))

"""1.0 Amps, 0 rad, and 0 rad/s. Input voltage of 0 v

Deliverable: Describe what you think is happening physically in each case above. Does
the result of your routine make sense based on your intuition?


I think what is happening is that in the various test cases we can mathematically see how the application 
or lack of a current and voltage can be modelled on a motor. For example on the first test case, all the values 
of the input array was set to 0 and a voltage of 2V was applied. Howver the lack of current means the motor has
not staretd spinning. in the last/3rd test we can see that a current is being apllied but the lack of a voltage 
means the motor will come to a stop.
"""

def unit_impulse(t: float) -> float:
  if t == 0:
    return 1.0
  else :
    return  0.

# Write your implementation

def unit_step(t: float) -> float:
  if t >= 0:
    return 1.0
  else: 
    return  0.0

# Write your implementation

def sin_wave(t: float) -> float:
  A= 5
  phi = 0
  omega =2* math.pi
  u_result = A *math.sin((omega*t) + phi)
  return  u_result

def zero_func(void):
  return 0.0

def rk2_integration(dyn_func: callable, u_func: callable, x_0: float,
t_0: float, t_f: float, delta_t: float) -> list:
    #t=t_0
    x_now = x_0
    list_return = [x_now]
    time_array= np.arange(t_0,t_f,delta_t)#keeps trakc of index and time value
    for i,t in enumerate(time_array):
      f_1 = dyn_func(list_return[i],u_func(t))
      f_2 = dyn_func((list_return[i]+(delta_t/2)*f_1),(u_func(t+(delta_t/2))))
      temp = x_now +delta_t *f_2
      list_return.append(temp)
      x_now = temp
      
    return list_return,time_array
#np.arange, enumerate

# This used to be our main DCMotor class
class DCMotorDynamics:

  def __init__(self, cfg: DCMotorConfig):
    self.A =  np.array([[-1*cfg.R/cfg.L, 0, -1*cfg.Km/cfg.L],
              [0, 0, 1],
              [cfg.Ktau/cfg.J, 0, -1*cfg.b/cfg.J]]) # ...
    self.B = np.array([1/cfg.L,
                       0 ,
                       0]) #...
    # This class is what you did in Practicum 2-1!
    

  def __call__(self, x: ArrayLike, u: float):
    x_dot = self.A @ x + self.B.dot(u) # <-- A needs to use matrix multiplication with x
    #x_dot = self.A.dot(x)+self.B.dot(u) # <---- This created a broadcast error. I fixed your B matrix.
    return x_dot
 

# This wrapper class represents your DCMotor plant:
class DCMotor:

  def __init__(self, cfg: DCMotorConfig):
    self.config = cfg
    self.dynamics = DCMotorDynamics(cfg)
  
  def output(self, x: ArrayLike):
    theta = x[1]
    # Here you will pick out the entry of the state vector that represents the
    # desired output
    # ...Implement...
    return theta

#testing1
dc_test = DCMotorDynamics(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =2.0
print(dc_test(dc_stats, u))

#tsting 2
dc_test_minus2 = DCMotorDynamics(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =-2.0
print(dc_test_minus2(dc_stats, u))

#testing3
dc_test = DCMotorDynamics(cfg)
dc_stats = np.array([0.0,0.0,0.0])
u =-2.0
print(dc_test(dc_stats, u))

def rk2_step(dyn_func: Callable, u_func: Callable, x: ArrayLike,
t: float, delta_t: float) -> ArrayLike:
  #list_return =
  f_1 = dyn_func(x,u_func(t))
  #print(f_1)
  f_2 = dyn_func((x+(delta_t/2)*f_1),(u_func(t+(delta_t/2))))
  temp = x +delta_t *f_2
  return temp
# Compute the *same* steps from your RK2 Integration routine

def simulate(plant, controller, x_0: ArrayLike, t_0: float, t_f: float,
delta_t: float) -> Tuple[ArrayLike, ArrayLike]:
    x_now = x_0
    list_return = [x_now]
    y_array = []
    time_array= np.arange(t_0,t_f,delta_t)#keeps trakc of index and time value
    for i,t in enumerate(time_array):
      #measure
      y = plant.output(x_now)
      y_array.append(y)
      #/store
      u_func = lambda t, measurement=y: controller(measurement)
      temp = rk2_step(plant.dynamics,u_func,x_now,t,delta_t)
      list_return.append(temp)
      x_now = temp
  
    return time_array,  np.array(y_array) # <-- I fixed your simulate function to return y_array as a numpy array!

# Setup your time and output histories
# Iterate over the time range just like before
  # Measure/store plant output using its interface
  # Apply controller using Python lambda
  # Take rk2_step
# Return the tuple of time and output histories

#testing Rk2

t_0 = 0.0
delta_t = 0.001
t_f = 0.5
dc_rk2_test = DCMotor(cfg)
cfg = DCMotorConfig(R=1.8, L=0.85e-2, Km=4.6, Ktau=6.2, b=0.035, J=0.032)
dcmotork2_test = DCMotor(cfg)
x = np.array([0,0,0])
x_testdata_1= rk2_integration(dcmotork2_test.dynamics,unit_impulse, x, t_0, t_f, delta_t)
x_testdata_2= rk2_integration(dcmotork2_test.dynamics,unit_step, x, t_0, t_f, delta_t)
x_testdata_3= rk2_integration(dcmotork2_test.dynamics,sin_wave, x, t_0, t_f, delta_t)
x_testdata_3= rk2_integration(dcmotork2_test.dynamics,sin_wave, x, t_0, t_f, delta_t)

new_x = np.array([2.5,0,0])
x_testdata_4= rk2_integration(dcmotork2_test.dynamics,sin_wave, new_x, t_0, t_f, delta_t)


plt.figure()
figure, sub_fig = plt.subplots(1, figsize=(10,20)) 
plt.subplot(8,2,1)
plt.plot(x_testdata_1[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle for unit impulse')

plt.subplot(8,2,2)
plt.plot(x_testdata_1[1])
plt.xlabel('time')
plt.ylabel('angular velocity')
plt.title('time vs angular velocity for unit impulse')

plt.subplot(8,2,3)
plt.plot(x_testdata_2[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle for unit step')

plt.subplot(8,2,4)
plt.plot(x_testdata_2[1])
plt.xlabel('time')
plt.ylabel('angular velocity')
plt.title('time vs angular velocity for unit step')

plt.subplot(8,2,5)
plt.plot(x_testdata_3[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle sin wave')

plt.subplot(8,2,6)
plt.plot(x_testdata_3[1])
plt.xlabel('time')
plt.ylabel('angular velcoity')
plt.title('time vs angular velcotiy for sin wave')

plt.subplot(8,2,7)
plt.plot(x_testdata_4[0])
plt.xlabel('time')
plt.ylabel('angle')
plt.title('time vs angle zero func')

plt.subplot(8,2,8)
plt.plot(x_testdata_4[1])
plt.xlabel('time')
plt.ylabel('angular')
plt.title('time vs angular zero func')
plt.tight_layout()
plt.show()

"""Describe what you think is happening to these variables given the initial conditions and
input functions. Does it make sense physically?


What i think is happening given the initial conditions is that the time vs angle graph does not equal 0. 
This is becuase the unit impulse is a small value applied to the motor and doesn't affect it. When looking 
at the angular velcoity graph we can see that the motor will rotate before coming to a stop. With the unit step
we can see that the motor moves at a constant rate. When a sinusoidal signal is applied we see that a siusodial 
wave is produced represnting the motor speed in respect to the voltage and current applied. For when the motor
starts with an iniital current of 2.5 Amps applied and 0 volts we can see that the motor will eventually stop 
moving and stablizie at 0 once the current is used up. 
"""

class DummyController:
# DummyController returns 0.0
  def __init__(self):
    self.value = 0.0
  def __call__(self, measurement: float):
    return self.value

Dummycontroller1 =DummyController()
dc_motortest = DCMotor(cfg)
ts, ys = simulate(dc_motortest,Dummycontroller1,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 0.5,delta_t = 0.001)

# So you have an error with t or y here. Time to see what they look like.
# print(ts.shape)
# print(ys) # Your y is a collection of state vectors! Yikes!
# print(np.array(ys).shape) # There is something wrong here! It says you are building a numpy array in a weird way. So y is messed up!

# When you have a bug, you need to chase it down!
# Comment out what is not working...
plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()
#plot theta

@dataclass
class PIDControllerConfig:
  Kp: float
  Ki: float
  Kd: float
  delta_t: float
  setpoint: float

class PIDController:
  def __init__(self, cfg: PIDControllerConfig) -> None:
    self.Kp = cfg.Kp
    self.Ki = cfg.Ki
    self.Kd =cfg.Kd
    self.delta_t = cfg.delta_t
    self.setpoint = cfg.setpoint
    self.area =0
    self.et_minus =0
  # write your implementation

  def __call__(self, measurement: float) -> float:
    e_t= self.setpoint- measurement
    self.area += e_t*self.delta_t
    u_t = (self.Kp * e_t)+(self.Ki *self.area )+ (self.Kd *((e_t -self.et_minus)/self.delta_t))
    self.et_minus = e_t
    return u_t

  # write your implementation

#testing my sanity
dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=10.0,Ki=100.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.
ğ¾_ğ‘ƒ = 10. 0, ğ¾_ğ¼ = 0. 0, ğ¾_ğ· = 0. 0. Setpoint at 1"""

dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=0.0,Ki=10.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.
ğ¾_ğ‘ƒ = 0. 0, ğ¾_ğ¼ = 10. 0, ğ¾_ğ· = 0. 0. Setpoint at 1"""

dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=2.0,Ki=0.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.
ğ¾_ğ‘ƒ = 2. 0, ğ¾_ğ¼ = 0. 0, ğ¾_ğ· = 0. 0. Setpoint at 1"""

dcmotor_pid_test = DCMotor(cfg)
pid_controller_test = PIDControllerConfig(Kp=10.0,Ki=0.0,Kd=0.0, delta_t = 0.001, setpoint=1.0)
pid_test = PIDController(pid_controller_test)
ts, ys = simulate(dcmotor_pid_test,pid_test,x_0 = [0.0, 0.0, 0.0] ,t_0 = 0.0,t_f = 5,delta_t = 0.001)


plt.plot(ts,ys)
plt.title('Angle vs. Time')
plt.xlabel('Time')
plt.ylabel('Angle')
plt.show()

"""Simulating control loop using the configuration given in previous evaluation.ğ¾_ğ‘ƒ = 10. 0, ğ¾_ğ¼ = 0. 0, ğ¾_ğ· = 0. 0. Setpoint at 1

Deliverable: For each case, plot the motor angle (Î¸) over your simulated time horizon.
Describe what you think is happening in each case above. How do the different
parameter values affect the controllerâ€™s performance?

As kp increases, the contrller becomes more controllable. This can be seen in the last 2 plots of Kp of 2 and Kp of 10 respectively. 
As the values increaed it can be seen the system converges to a vlaue of 1 radian and as result becomes more controllabe.
"""